S <- paste("<",S[,2],">",sep = "") # novo símbolo
} else if (S=="<var>"){
rule <- P[[3]][1+C[i,j]%%length(P[[3]])] # determina a regra a ser aplicada
derivacao[i] <- sub(S, rule, derivacao[i]) # atualiza derivacao por substituição
S <- stringr::str_match(derivacao[i], "<(.*?)>") # acha o primeiro <..>
S <- paste("<",S[,2],">",sep = "") # novo símbolo
} else if (S=="<sin>"){
rule <- P[[4]][1+C[i,j]%%length(P[[4]])] # determina a regra a ser aplicada
derivacao[i] <- sub(S, rule, derivacao[i]) # atualiza derivacao por substituição
S <- stringr::str_match(derivacao[i], "<(.*?)>") # acha o primeiro <..>
S <- paste("<",S[,2],">",sep = "") # novo símbolo
} else if (S=="<log>"){
rule <- P[[5]][1+C[i,j]%%length(P[[5]])] # determina a regra a ser aplicada
derivacao[i] <- sub(S, rule, derivacao[i]) # atualiza derivacao por substituição
S <- stringr::str_match(derivacao[i], "<(.*?)>") # acha o primeiro <..>
S <- paste("<",S[,2],">",sep = "") # novo símbolo
} else if (S=="<e>"){
rule <- P[[6]][1+C[i,j]%%length(P[[6]])] # determina a regra a ser aplicada
derivacao[i] <- sub(S, rule, derivacao[i]) # atualiza derivacao por substituição
S <- stringr::str_match(derivacao[i], "<(.*?)>") # acha o primeiro <..>
S <- paste("<",S[,2],">",sep = "") # novo símbolo
}
}
}
derivacao
S
# Limpa área de trabalho
rm(list = ls())
# Não Terminais
V <- c("<exp>","<op>","<var>","<sin>","<log>","<e>")
# Terminais
op <- c("+","-","/","*","^")
var <- c("x","y","z","u","v","w","p","q")
sigma <- c(op,var)
#sigma <- c("+","-","/","*","x","y")
# Símbolo Inicial
S <- "<exp>"
# Produções
P <- list(c("<exp><op><exp>","<var>"),op,var,c("sin(<exp>)"),c("log(<exp>)"),c("exp(<exp>)"))
# Limpa área de trabalho
rm(list = ls())
# Não Terminais
V <- c("<exp>","<op>","<var>","<sin>","<log>","<e>")
# Terminais
op <- c("+","-","/","*","^")
var <- c("x","y","z","u","v","w","p","q")
sigma <- c(op,var)
#sigma <- c("+","-","/","*","x","y")
# Símbolo Inicial
S <- "<exp>"
# Produções
P <- list(c("<exp><op><exp>","<var>","sin(<exp>)","log(<exp>)","exp(<exp>)"),op,var)
cromo_size <- 100
cromo_quant <- 200
max_gene <- 10000
C <- matrix(sample(max_gene,cromo_size),cromo_quant,cromo_size) # Ci = C[i,]
# Geração de constantes
max_const <- 1000
const_quant <- 100
const <- sample(max_const,const_quant)
trainingData <- read.csv(file="training.csv", header=TRUE, sep=",")
# SOMENTE PARA TESTE
#C[1,] <- c(4,15,75,8,41,12)
#C[2,] <- c(6,10,255,7,50,35)
#C[3,] <- c(9,40,7,43,2,11)
#C[4,] <- c(20,5,200,5,67,23)
# FIM
derivacao <- rep(S,cromo_quant) # símbolo inicial
for (i in 1:cromo_quant) {
S <- "<exp>"
j <- 0
count <- 0
while (S!="<NA>"){
count <- count + 1
# evitar loop infinito, para cromossomos mal escolhidos:
if (count > 100){
tmp <- stringr::str_match(derivacao[i], ".*?<")
tmp <- substr(tmp,1,nchar(tmp)-1)
last.char <- substr(tmp,nchar(tmp),nchar(tmp))
if (!last.char%in%var || is.na(tmp)){ # se terminar em operador
tmp <- substr(tmp,1,nchar(tmp)-1)
}
derivacao[i] <- tmp
S <- "<NA>"
}
j <- j%%cromo_size + 1
if (S=="<exp>"){
rule <- P[[1]][1+C[i,j]%%length(P[[1]])] # determina a regra a ser aplicada
derivacao[i] <- sub(S, rule, derivacao[i]) # atualiza derivacao por substituição
S <- stringr::str_match(derivacao[i], "<(.*?)>") # acha o primeiro <..>
S <- paste("<",S[,2],">",sep = "") # novo símbolo
} else if (S=="<op>"){
rule <- P[[2]][1+C[i,j]%%length(P[[2]])] # determina a regra a ser aplicada
derivacao[i] <- sub(S, rule, derivacao[i]) # atualiza derivacao por substituição
S <- stringr::str_match(derivacao[i], "<(.*?)>") # acha o primeiro <..>
S <- paste("<",S[,2],">",sep = "") # novo símbolo
} else if (S=="<var>"){
rule <- P[[3]][1+C[i,j]%%length(P[[3]])] # determina a regra a ser aplicada
derivacao[i] <- sub(S, rule, derivacao[i]) # atualiza derivacao por substituição
S <- stringr::str_match(derivacao[i], "<(.*?)>") # acha o primeiro <..>
S <- paste("<",S[,2],">",sep = "") # novo símbolo
} else if (S=="<sin>"){
rule <- P[[4]][1+C[i,j]%%length(P[[4]])] # determina a regra a ser aplicada
derivacao[i] <- sub(S, rule, derivacao[i]) # atualiza derivacao por substituição
S <- stringr::str_match(derivacao[i], "<(.*?)>") # acha o primeiro <..>
S <- paste("<",S[,2],">",sep = "") # novo símbolo
} else if (S=="<log>"){
rule <- P[[5]][1+C[i,j]%%length(P[[5]])] # determina a regra a ser aplicada
derivacao[i] <- sub(S, rule, derivacao[i]) # atualiza derivacao por substituição
S <- stringr::str_match(derivacao[i], "<(.*?)>") # acha o primeiro <..>
S <- paste("<",S[,2],">",sep = "") # novo símbolo
} else if (S=="<e>"){
rule <- P[[6]][1+C[i,j]%%length(P[[6]])] # determina a regra a ser aplicada
derivacao[i] <- sub(S, rule, derivacao[i]) # atualiza derivacao por substituição
S <- stringr::str_match(derivacao[i], "<(.*?)>") # acha o primeiro <..>
S <- paste("<",S[,2],">",sep = "") # novo símbolo
}
}
}
derivacao
View(derivacao)
# Limpa área de trabalho
rm(list = ls())
# Não Terminais
V <- c("<exp>","<op>","<var>","<sin>","<log>","<e>")
# Terminais
op <- c("+","-","/","*","^")
var <- c("x","y","z","u","v","w","p","q")
sigma <- c(op,var)
#sigma <- c("+","-","/","*","x","y")
# Símbolo Inicial
S <- "<exp>"
# Produções
P <- list(c("<exp><op><exp>","<var>","sin(<exp>)","log(<exp>)","exp(<exp>)"),op,var)
cromo_size <- 100
cromo_quant <- 200
max_gene <- 10000
C <- matrix(sample(max_gene,cromo_size),cromo_quant,cromo_size) # Ci = C[i,]
# Geração de constantes
max_const <- 1000
const_quant <- 100
const <- sample(max_const,const_quant)
trainingData <- read.csv(file="training.csv", header=TRUE, sep=",")
# SOMENTE PARA TESTE
#C[1,] <- c(4,15,75,8,41,12)
#C[2,] <- c(6,10,255,7,50,35)
#C[3,] <- c(9,40,7,43,2,11)
#C[4,] <- c(20,5,200,5,67,23)
# FIM
S <- "<exp>"
derivacao <- rep(S,cromo_quant) # símbolo inicial
for (i in 1:cromo_quant) {
S <- "<exp>"
j <- 0
count <- 0
while (S!="<NA>"){
count <- count + 1
# evitar loop infinito, para cromossomos mal escolhidos:
if (count > 100){
tmp <- stringr::str_match(derivacao[i], ".*?<")
tmp <- substr(tmp,1,nchar(tmp)-1)
last.char <- substr(tmp,nchar(tmp),nchar(tmp))
if (!last.char%in%var || is.na(tmp)){ # se terminar em operador
tmp <- substr(tmp,1,nchar(tmp)-1)
}
derivacao[i] <- tmp
S <- "<NA>"
}
j <- j%%cromo_size + 1
if (S=="<exp>"){
rule <- P[[1]][1+C[i,j]%%length(P[[1]])] # determina a regra a ser aplicada
derivacao[i] <- sub(S, rule, derivacao[i]) # atualiza derivacao por substituição
S <- stringr::str_match(derivacao[i], "<(.*?)>") # acha o primeiro <..>
S <- paste("<",S[,2],">",sep = "") # novo símbolo
} else if (S=="<op>"){
rule <- P[[2]][1+C[i,j]%%length(P[[2]])] # determina a regra a ser aplicada
derivacao[i] <- sub(S, rule, derivacao[i]) # atualiza derivacao por substituição
S <- stringr::str_match(derivacao[i], "<(.*?)>") # acha o primeiro <..>
S <- paste("<",S[,2],">",sep = "") # novo símbolo
} else if (S=="<var>"){
rule <- P[[3]][1+C[i,j]%%length(P[[3]])] # determina a regra a ser aplicada
derivacao[i] <- sub(S, rule, derivacao[i]) # atualiza derivacao por substituição
S <- stringr::str_match(derivacao[i], "<(.*?)>") # acha o primeiro <..>
S <- paste("<",S[,2],">",sep = "") # novo símbolo
} else if (S=="<sin>"){
rule <- P[[4]][1+C[i,j]%%length(P[[4]])] # determina a regra a ser aplicada
derivacao[i] <- sub(S, rule, derivacao[i]) # atualiza derivacao por substituição
S <- stringr::str_match(derivacao[i], "<(.*?)>") # acha o primeiro <..>
S <- paste("<",S[,2],">",sep = "") # novo símbolo
} else if (S=="<log>"){
rule <- P[[5]][1+C[i,j]%%length(P[[5]])] # determina a regra a ser aplicada
derivacao[i] <- sub(S, rule, derivacao[i]) # atualiza derivacao por substituição
S <- stringr::str_match(derivacao[i], "<(.*?)>") # acha o primeiro <..>
S <- paste("<",S[,2],">",sep = "") # novo símbolo
} else if (S=="<e>"){
rule <- P[[6]][1+C[i,j]%%length(P[[6]])] # determina a regra a ser aplicada
derivacao[i] <- sub(S, rule, derivacao[i]) # atualiza derivacao por substituição
S <- stringr::str_match(derivacao[i], "<(.*?)>") # acha o primeiro <..>
S <- paste("<",S[,2],">",sep = "") # novo símbolo
}
}
}
derivacao
# Limpa área de trabalho
rm(list = ls())
# Não Terminais
V <- c("<exp>","<op>","<var>","<sin>","<log>","<e>")
# Terminais
op <- c("+","-","/","*","^")
var <- c("x","y","z","u","v","w","p","q")
sigma <- c(op,var)
#sigma <- c("+","-","/","*","x","y")
# Símbolo Inicial
S <- "<exp>"
# Produções
#P <- list(c("<exp><op><exp>","<var>","sin(<exp>)","log(<exp>)","exp(<exp>)"),op,var)
P <- list(c("<exp><op><exp>","<var>"),op,var)
cromo_size <- 100
cromo_quant <- 200
max_gene <- 10000
C <- matrix(sample(max_gene,cromo_size),cromo_quant,cromo_size) # Ci = C[i,]
# Geração de constantes
max_const <- 1000
const_quant <- 100
const <- sample(max_const,const_quant)
trainingData <- read.csv(file="training.csv", header=TRUE, sep=",")
# SOMENTE PARA TESTE
#C[1,] <- c(4,15,75,8,41,12)
#C[2,] <- c(6,10,255,7,50,35)
#C[3,] <- c(9,40,7,43,2,11)
#C[4,] <- c(20,5,200,5,67,23)
# FIM
S <- "<exp>"
derivacao <- rep(S,cromo_quant) # símbolo inicial
for (i in 1:cromo_quant) {
S <- "<exp>"
j <- 0
count <- 0
while (S!="<NA>"){
count <- count + 1
# evitar loop infinito, para cromossomos mal escolhidos:
if (count > 100){
tmp <- stringr::str_match(derivacao[i], ".*?<")
tmp <- substr(tmp,1,nchar(tmp)-1)
last.char <- substr(tmp,nchar(tmp),nchar(tmp))
if (!last.char%in%var || is.na(tmp)){ # se terminar em operador
tmp <- substr(tmp,1,nchar(tmp)-1)
}
derivacao[i] <- tmp
S <- "<NA>"
}
j <- j%%cromo_size + 1
if (S=="<exp>"){
rule <- P[[1]][1+C[i,j]%%length(P[[1]])] # determina a regra a ser aplicada
derivacao[i] <- sub(S, rule, derivacao[i]) # atualiza derivacao por substituição
S <- stringr::str_match(derivacao[i], "<(.*?)>") # acha o primeiro <..>
S <- paste("<",S[,2],">",sep = "") # novo símbolo
} else if (S=="<op>"){
rule <- P[[2]][1+C[i,j]%%length(P[[2]])] # determina a regra a ser aplicada
derivacao[i] <- sub(S, rule, derivacao[i]) # atualiza derivacao por substituição
S <- stringr::str_match(derivacao[i], "<(.*?)>") # acha o primeiro <..>
S <- paste("<",S[,2],">",sep = "") # novo símbolo
} else if (S=="<var>"){
rule <- P[[3]][1+C[i,j]%%length(P[[3]])] # determina a regra a ser aplicada
derivacao[i] <- sub(S, rule, derivacao[i]) # atualiza derivacao por substituição
S <- stringr::str_match(derivacao[i], "<(.*?)>") # acha o primeiro <..>
S <- paste("<",S[,2],">",sep = "") # novo símbolo
} else if (S=="<sin>"){
rule <- P[[4]][1+C[i,j]%%length(P[[4]])] # determina a regra a ser aplicada
derivacao[i] <- sub(S, rule, derivacao[i]) # atualiza derivacao por substituição
S <- stringr::str_match(derivacao[i], "<(.*?)>") # acha o primeiro <..>
S <- paste("<",S[,2],">",sep = "") # novo símbolo
} else if (S=="<log>"){
rule <- P[[5]][1+C[i,j]%%length(P[[5]])] # determina a regra a ser aplicada
derivacao[i] <- sub(S, rule, derivacao[i]) # atualiza derivacao por substituição
S <- stringr::str_match(derivacao[i], "<(.*?)>") # acha o primeiro <..>
S <- paste("<",S[,2],">",sep = "") # novo símbolo
} else if (S=="<e>"){
rule <- P[[6]][1+C[i,j]%%length(P[[6]])] # determina a regra a ser aplicada
derivacao[i] <- sub(S, rule, derivacao[i]) # atualiza derivacao por substituição
S <- stringr::str_match(derivacao[i], "<(.*?)>") # acha o primeiro <..>
S <- paste("<",S[,2],">",sep = "") # novo símbolo
}
}
}
derivacao
C
# Limpa área de trabalho
rm(list = ls())
# Não Terminais
V <- c("<exp>","<op>","<var>","<sin>","<log>","<e>")
# Terminais
op <- c("+","-","/","*","^")
var <- c("x","y","z","u","v","w","p","q")
sigma <- c(op,var)
#sigma <- c("+","-","/","*","x","y")
# Símbolo Inicial
S <- "<exp>"
# Produções
#P <- list(c("<exp><op><exp>","<var>","sin(<exp>)","log(<exp>)","exp(<exp>)"),op,var)
P <- list(c("<exp><op><exp>","<var>"),op,var)
cromo_size <- 100
cromo_quant <- 200
max_gene <- 10000
C <- matrix(sample(max_gene,cromo_size),cromo_quant,cromo_size) # Ci = C[i,]
# Geração de constantes
max_const <- 1000
const_quant <- 100
const <- sample(max_const,const_quant)
trainingData <- read.csv(file="training.csv", header=TRUE, sep=",")
# SOMENTE PARA TESTE
#C[1,] <- c(4,15,75,8,41,12)
#C[2,] <- c(6,10,255,7,50,35)
#C[3,] <- c(9,40,7,43,2,11)
#C[4,] <- c(20,5,200,5,67,23)
# FIM
S <- "<exp>"
derivacao <- rep(S,cromo_quant) # símbolo inicial
for (i in 1:cromo_quant) {
S <- "<exp>"
j <- 0
count <- 0
while (S!="<NA>"){
count <- count + 1
# evitar loop infinito, para cromossomos mal escolhidos:
if (count > 100){
tmp <- stringr::str_match(derivacao[i], ".*?<")
tmp <- substr(tmp,1,nchar(tmp)-1)
last.char <- substr(tmp,nchar(tmp),nchar(tmp))
if (!last.char%in%var || is.na(tmp)){ # se terminar em operador
tmp <- substr(tmp,1,nchar(tmp)-1)
}
derivacao[i] <- tmp
S <- "<NA>"
}
j <- j%%cromo_size + 1
if (S=="<exp>"){
rule <- P[[1]][1+C[i,j]%%length(P[[1]])] # determina a regra a ser aplicada
derivacao[i] <- sub(S, rule, derivacao[i]) # atualiza derivacao por substituição
S <- stringr::str_match(derivacao[i], "<(.*?)>") # acha o primeiro <..>
S <- paste("<",S[,2],">",sep = "") # novo símbolo
} else if (S=="<op>"){
rule <- P[[2]][1+C[i,j]%%length(P[[2]])] # determina a regra a ser aplicada
derivacao[i] <- sub(S, rule, derivacao[i]) # atualiza derivacao por substituição
S <- stringr::str_match(derivacao[i], "<(.*?)>") # acha o primeiro <..>
S <- paste("<",S[,2],">",sep = "") # novo símbolo
} else if (S=="<var>"){
rule <- P[[3]][1+C[i,j]%%length(P[[3]])] # determina a regra a ser aplicada
derivacao[i] <- sub(S, rule, derivacao[i]) # atualiza derivacao por substituição
S <- stringr::str_match(derivacao[i], "<(.*?)>") # acha o primeiro <..>
S <- paste("<",S[,2],">",sep = "") # novo símbolo
} else if (S=="<sin>"){
rule <- P[[4]][1+C[i,j]%%length(P[[4]])] # determina a regra a ser aplicada
derivacao[i] <- sub(S, rule, derivacao[i]) # atualiza derivacao por substituição
S <- stringr::str_match(derivacao[i], "<(.*?)>") # acha o primeiro <..>
S <- paste("<",S[,2],">",sep = "") # novo símbolo
} else if (S=="<log>"){
rule <- P[[5]][1+C[i,j]%%length(P[[5]])] # determina a regra a ser aplicada
derivacao[i] <- sub(S, rule, derivacao[i]) # atualiza derivacao por substituição
S <- stringr::str_match(derivacao[i], "<(.*?)>") # acha o primeiro <..>
S <- paste("<",S[,2],">",sep = "") # novo símbolo
} else if (S=="<e>"){
rule <- P[[6]][1+C[i,j]%%length(P[[6]])] # determina a regra a ser aplicada
derivacao[i] <- sub(S, rule, derivacao[i]) # atualiza derivacao por substituição
S <- stringr::str_match(derivacao[i], "<(.*?)>") # acha o primeiro <..>
S <- paste("<",S[,2],">",sep = "") # novo símbolo
}
}
}
# Limpa área de trabalho
rm(list = ls())
# Não Terminais
V <- c("<exp>","<op>","<var>","<sin>","<log>","<e>")
# Terminais
op <- c("+","-","/","*","^")
var <- c("x","y","z","u","v","w","p","q")
sigma <- c(op,var)
#sigma <- c("+","-","/","*","x","y")
# Símbolo Inicial
S <- "<exp>"
# Produções
#P <- list(c("<exp><op><exp>","<var>","sin(<exp>)","log(<exp>)","exp(<exp>)"),op,var)
P <- list(c("<exp><op><exp>","<var>"),op,var)
cromo_size <- 100
cromo_quant <- 200
max_gene <- 10000
C <- matrix(sample(max_gene,cromo_size),cromo_quant,cromo_size) # Ci = C[i,]
# Geração de constantes
max_const <- 1000
const_quant <- 100
const <- sample(max_const,const_quant)
trainingData <- read.csv(file="training.csv", header=TRUE, sep=",")
S <- "<exp>"
derivacao <- rep(S,cromo_quant) # símbolo inicial
for (i in 1:cromo_quant) {
S <- "<exp>"
j <- 0
count <- 0
while (S!="<NA>"){
count <- count + 1
# evitar loop infinito, para cromossomos mal escolhidos:
if (count > 100){
tmp <- stringr::str_match(derivacao[i], ".*?<")
tmp <- substr(tmp,1,nchar(tmp)-1)
last.char <- substr(tmp,nchar(tmp),nchar(tmp))
if (!last.char%in%var || is.na(tmp)){ # se terminar em operador
tmp <- substr(tmp,1,nchar(tmp)-1)
}
derivacao[i] <- tmp
S <- "<NA>"
}
j <- j%%cromo_size + 1
if (S=="<exp>"){
rule <- P[[1]][1+C[i,j]%%length(P[[1]])] # determina a regra a ser aplicada
derivacao[i] <- sub(S, rule, derivacao[i]) # atualiza derivacao por substituição
S <- stringr::str_match(derivacao[i], "<(.*?)>") # acha o primeiro <..>
S <- paste("<",S[,2],">",sep = "") # novo símbolo
} else if (S=="<op>"){
rule <- P[[2]][1+C[i,j]%%length(P[[2]])] # determina a regra a ser aplicada
derivacao[i] <- sub(S, rule, derivacao[i]) # atualiza derivacao por substituição
S <- stringr::str_match(derivacao[i], "<(.*?)>") # acha o primeiro <..>
S <- paste("<",S[,2],">",sep = "") # novo símbolo
} else if (S=="<var>"){
rule <- P[[3]][1+C[i,j]%%length(P[[3]])] # determina a regra a ser aplicada
derivacao[i] <- sub(S, rule, derivacao[i]) # atualiza derivacao por substituição
S <- stringr::str_match(derivacao[i], "<(.*?)>") # acha o primeiro <..>
S <- paste("<",S[,2],">",sep = "") # novo símbolo
}
}
}
derivacao
# SOMENTE PARA TESTE
#C[1,] <- c(4,15,75,8,41,12)
#C[2,] <- c(6,10,255,7,50,35)
#C[3,] <- c(9,40,7,43,2,11)
#C[4,] <- c(20,5,200,5,67,23)
# FIM
S <- "<exp>"
derivacao <- rep(S,cromo_quant) # símbolo inicial
for (i in 1:cromo_quant) {
S <- "<exp>"
j <- 0
count <- 0
while (S!="<NA>"){
count <- count + 1
# evitar loop infinito, para cromossomos mal escolhidos:
if (count > 100){
tmp <- stringr::str_match(derivacao[i], ".*?<")
tmp <- substr(tmp,1,nchar(tmp)-1)
last.char <- substr(tmp,nchar(tmp),nchar(tmp))
if (!last.char%in%var || is.na(tmp)){ # se terminar em operador
tmp <- substr(tmp,1,nchar(tmp)-1)
}
derivacao[i] <- tmp
S <- "<NA>"
}
j <- j%%cromo_size + 1
if (S=="<exp>"){
rule <- P[[1]][1+C[i,j]%%length(P[[1]])] # determina a regra a ser aplicada
derivacao[i] <- sub(S, rule, derivacao[i]) # atualiza derivacao por substituição
S <- stringr::str_match(derivacao[i], "<(.*?)>") # acha o primeiro <..>
S <- paste("<",S[,2],">",sep = "") # novo símbolo
} else if (S=="<op>"){
rule <- P[[2]][1+C[i,j]%%length(P[[2]])] # determina a regra a ser aplicada
derivacao[i] <- sub(S, rule, derivacao[i]) # atualiza derivacao por substituição
S <- stringr::str_match(derivacao[i], "<(.*?)>") # acha o primeiro <..>
S <- paste("<",S[,2],">",sep = "") # novo símbolo
} else if (S=="<var>"){
rule <- P[[3]][1+C[i,j]%%length(P[[3]])] # determina a regra a ser aplicada
derivacao[i] <- sub(S, rule, derivacao[i]) # atualiza derivacao por substituição
S <- stringr::str_match(derivacao[i], "<(.*?)>") # acha o primeiro <..>
S <- paste("<",S[,2],">",sep = "") # novo símbolo
} else if (S=="<sin>"){
rule <- P[[4]][1+C[i,j]%%length(P[[4]])] # determina a regra a ser aplicada
derivacao[i] <- sub(S, rule, derivacao[i]) # atualiza derivacao por substituição
S <- stringr::str_match(derivacao[i], "<(.*?)>") # acha o primeiro <..>
S <- paste("<",S[,2],">",sep = "") # novo símbolo
} else if (S=="<log>"){
rule <- P[[5]][1+C[i,j]%%length(P[[5]])] # determina a regra a ser aplicada
derivacao[i] <- sub(S, rule, derivacao[i]) # atualiza derivacao por substituição
S <- stringr::str_match(derivacao[i], "<(.*?)>") # acha o primeiro <..>
S <- paste("<",S[,2],">",sep = "") # novo símbolo
} else if (S=="<e>"){
rule <- P[[6]][1+C[i,j]%%length(P[[6]])] # determina a regra a ser aplicada
derivacao[i] <- sub(S, rule, derivacao[i]) # atualiza derivacao por substituição
S <- stringr::str_match(derivacao[i], "<(.*?)>") # acha o primeiro <..>
S <- paste("<",S[,2],">",sep = "") # novo símbolo
}
}
}
C
derivacao
C
C <- matrix(sample(max_gene,cromo_size),cromo_quant,cromo_size) # Ci = C[i,]
sample(10,2)
sample(10,2)
sample(10,2)
sample(max_gene,cromo_size)
sample(max_gene,cromo_size)
C <- matrix(sample(max_gene,cromo_size),cromo_quant,cromo_size) # Ci = C[i,]
View(C)
cromo_size <- 50
cromo_quant <- 200
max_gene <- 10000
C <- matrix(sample(max_gene,cromo_size),cromo_quant,cromo_size) # Ci = C[i,]
# Geração de constantes
max_const <- 1000
const_quant <- 100
const <- sample(max_const,const_quant)
View(C)
C[1,]
C[2,]
