}
erroQuadraticoMedio[k] <- mean((training.data - (training.model))^2)
}
## Torneio de Cromossomos
sorteados <- c()
invalidosNanInf <- which(erroQuadraticoMedio %in% c(NaN,Inf))
invalidosVazio <- which(derivacao %in% c(""))
invalidos <- c(invalidosNanInf,invalidosVazio,which(duplicated(derivacao)))
validos <-c(1:length(derivacao))[which(!c(1:length(derivacao)) %in% invalidos)]
first_sorteados <- length(validos)%/%first_sorteados_fraction
order_size <- (order_size_fraction*length(validos))%/%first_sorteados_fraction
ordenados <- validos[order(erroQuadraticoMedio[validos])][1:order_size]
sorteados <- validos[order(erroQuadraticoMedio[validos])][1:first_sorteados]
if(length(sorteados)>0)
{
if(sqrt(erroQuadraticoMedio[sorteados[1]])<raizErroQuadraticoMedioMin)
{
raizErroQuadraticoMedioMin<-sqrt(erroQuadraticoMedio[sorteados[1]])
cromossomo_vencedor <- C[sorteados[1],]
derivacao_vencedora <- derivacao[sorteados[1]]
cat("Achou pto de mínimo: ",raizErroQuadraticoMedioMin," com derivação: ",derivacao_vencedora,"\n")
}
}
for (i in (first_sorteados+1):(order_size*prop_filhos+first_sorteados+1)){
sorteio <- rep(NA,cromo_quant)
pos <- sample(ordenados,2) # sorteio dois crommossomos
sorteio[pos] <- pos
sorteados <- c(sorteados,which.min(erroQuadraticoMedio[sorteio]))
}
for (i in (order_size*prop_filhos+first_sorteados+2):cromo_quant){
sorteio <- rep(NA,cromo_quant)
pos <- sample(validos,2) # sorteio dois crommossomos
sorteio[pos] <- pos
sorteados <- c(sorteados,which.min(erroQuadraticoMedio[sorteio]))
}
C <- C[sorteados,]
## Cruzamento de Cromossomos
i <- (first_sorteados+1)
while (i < length(sorteados)){
# avalia a possibilidade de cruzamento de cada par
vai.cruzar <- runif(1)
if (vai.cruzar<=p.cruzamento){ # realiza cruzamento
pto.cruza <- endCromo[i]
if(pto.cruza > endCromo[i+1])
{
pto.cruza <- endCromo[i+1]
}
pto.cruza <- sample(pto.cruza-1,1)
index_pai <- i
index_mae <- i+1
tmp <- C[index_pai,(pto.cruza+1):cromo_size]
C[index_pai,(pto.cruza+1):cromo_size] <- C[index_mae,(pto.cruza+1):cromo_size]
C[index_mae,(pto.cruza+1):cromo_size] <- tmp
}
i <- i+2 # pula o próximo cromossomo (estamos olhando os pares)
}
## Mutação
vai.mutar <- matrix(runif(cromo_quant*cromo_size),cromo_quant,cromo_size)
divisa_prob <- cromo_quant%/%first_sorteados_fraction
for (i in (first_sorteados+1):cromo_quant){
linhaMutar <- vai.mutar[i,]
prob<-p.mutacao[i%/%divisa_prob+1]
if(prob*endCromo[i]<0.3)
{
prob <- 0.3/endCromo[i]
}
id <- which(linhaMutar < prob)
for (j in 1:length(id)){
coluna <- id[j]
C[i,coluna] <- sample(max_gene,1)
}
}
}
raizErroQuadraticoMedioMin
write.table()
vencedor
C[1,]
derivacao_vencedora
write.table(C[1,],file="cbom2.csv", row.names = FALSE,sep = ",", quote = FALSE)
cbom <- read.csv(file="cbom.csv", header=TRUE, sep=",")
cbom
cbom <- read.csv(file="cbom.csv", header=TRUE, sep=",")
cbom
# Adicionando o melhor cromossomo da geração passada
cbom <- read.csv(file="cbom.csv", header=TRUE)
cbom <- cbom[1:dim(cbom)[1],]
C[1,] <- cbom
knitr::opts_chunk$set(echo = TRUE)
N <- 50 # número de gerações
ngeracoes <- ngeracoes + N
for (g in 1:N){
## Gerando Derivação
if(g%%5 == 0){
cat("Geração: ", g,"\n")
}
S <- "<exp>"
derivacao <- rep(S,cromo_quant) # símbolo inicial
endCromo <- array(0,cromo_quant)
for (i in 1:cromo_quant) {
S <- "<exp>"
j <- 0
count <- 0
while (S!="<NA>"){
count <- count + 1
# evitar loop infinito, para cromossomos mal escolhidos:
if (count > cromo_size){
tmp <- stringr::str_match(derivacao[i], ".*?<")
tmp <- substr(tmp,1,nchar(tmp)-1)
if (is.na(tmp)){
last.char <- substr(tmp,nchar(derivacao[i]),nchar(derivacao[i]))
if (!last.char%in%var){
tmp <- substr(derivacao[i],1,nchar(derivacao[i])-1)
}
} else {
last.char <- substr(tmp,nchar(tmp),nchar(tmp))
while (!last.char%in%var){
# se terminar em operador
if (last.char%in%op){
tmp <- substr(tmp,1,nchar(tmp)-1)
} else if (substr(tmp,nchar(tmp)-1,nchar(tmp))=="^("){
tmp <- substr(tmp,1,nchar(tmp)-2)
} else if (substr(tmp,nchar(tmp)-5,nchar(tmp))=="asinh("){
tmp <- substr(tmp,1,nchar(tmp)-6)
}  else if (substr(tmp,nchar(tmp)-5,nchar(tmp))=="acosh("){
tmp <- substr(tmp,1,nchar(tmp)-6)
}  else if (substr(tmp,nchar(tmp)-5,nchar(tmp))=="atanh("){
tmp <- substr(tmp,1,nchar(tmp)-6)
} else if (substr(tmp,nchar(tmp)-1,nchar(tmp))=="h("){
tmp <- substr(tmp,1,nchar(tmp)-5)
} else if (substr(tmp,nchar(tmp)-4,nchar(tmp))=="sqrt("){
tmp <- substr(tmp,1,nchar(tmp)-5)
} else if (substr(tmp,nchar(tmp)-4,nchar(tmp))=="asin("){
tmp <- substr(tmp,1,nchar(tmp)-5)
}  else if (substr(tmp,nchar(tmp)-4,nchar(tmp))=="acos("){
tmp <- substr(tmp,1,nchar(tmp)-5)
}  else if (substr(tmp,nchar(tmp)-4,nchar(tmp))=="atan("){
tmp <- substr(tmp,1,nchar(tmp)-5)
} else if (last.char=="("){
tmp <- substr(tmp,1,nchar(tmp)-4)
}
last.char <- substr(tmp,nchar(tmp),nchar(tmp))
}
endCromo[i] <- -1
}
# colocar parênteses restantes
abrindo <- stringr::str_count(tmp,"\\(")
fechando <- stringr::str_count(tmp,"\\)")
add <- strrep(")",abrindo-fechando)
tmp <- paste(tmp,add,sep = "")
derivacao[i] <- tmp
S <- "<NA>"
}
j <- j%%cromo_size + 1
if (S=="<exp>"){
rule <- P[[1]][1+C[i,j]%%length(P[[1]])] # determina a regra a ser aplicada
derivacao[i] <- sub(S, rule, derivacao[i]) # atualiza derivacao por substituição
S <- stringr::str_match(derivacao[i], "<(.*?)>") # acha o primeiro <..>
S <- paste("<",S[,2],">",sep = "") # novo símbolo
} else if (S=="<op>"){
rule <- P[[2]][1+C[i,j]%%length(P[[2]])] # determina a regra a ser aplicada
derivacao[i] <- sub(S, rule, derivacao[i]) # atualiza derivacao por substituição
S <- stringr::str_match(derivacao[i], "<(.*?)>") # acha o primeiro <..>
S <- paste("<",S[,2],">",sep = "") # novo símbolo
} else if (S=="<var>"){
rule <- P[[3]][1+C[i,j]%%length(P[[3]])] # determina a regra a ser aplicada
derivacao[i] <- sub(S, rule, derivacao[i]) # atualiza derivacao por substituição
S <- stringr::str_match(derivacao[i], "<(.*?)>") # acha o primeiro <..>
S <- paste("<",S[,2],">",sep = "") # novo símbolo
}
}
endCromo[i] <- endCromo[i] + count
}
## Avaliação dos Cromossomos
training.model <- trainingData[,c("strength")]
erroQuadraticoMedio <- rep(0,cromo_quant)
for (k in 1:cromo_quant){
training.data <- c()
for (i in 1:length(training.model)){
x <- trainingData[i,2]
y <- trainingData[i,3]
z <- trainingData[i,4]
u <- trainingData[i,5]
v <- trainingData[i,6]
w <- trainingData[i,7]
p <- trainingData[i,8]
q <- trainingData[i,9]
valor <- suppressWarnings(eval(parse(text=derivacao[k])))
training.data <- c(training.data,valor)
}
erroQuadraticoMedio[k] <- mean((training.data - (training.model))^2)
}
## Torneio de Cromossomos
sorteados <- c()
invalidosNanInf <- which(erroQuadraticoMedio %in% c(NaN,Inf))
invalidosVazio <- which(derivacao %in% c(""))
invalidos <- c(invalidosNanInf,invalidosVazio,which(duplicated(derivacao)))
validos <-c(1:length(derivacao))[which(!c(1:length(derivacao)) %in% invalidos)]
first_sorteados <- length(validos)%/%first_sorteados_fraction
order_size <- (order_size_fraction*length(validos))%/%first_sorteados_fraction
ordenados <- validos[order(erroQuadraticoMedio[validos])][1:order_size]
sorteados <- validos[order(erroQuadraticoMedio[validos])][1:first_sorteados]
if(length(sorteados)>0)
{
if(sqrt(erroQuadraticoMedio[sorteados[1]])<raizErroQuadraticoMedioMin)
{
raizErroQuadraticoMedioMin<-sqrt(erroQuadraticoMedio[sorteados[1]])
cromossomo_vencedor <- C[sorteados[1],]
derivacao_vencedora <- derivacao[sorteados[1]]
cat("Achou pto de mínimo: ",raizErroQuadraticoMedioMin," com derivação: ",derivacao_vencedora,"\n")
}
}
for (i in (first_sorteados+1):(order_size*prop_filhos+first_sorteados+1)){
sorteio <- rep(NA,cromo_quant)
pos <- sample(ordenados,2) # sorteio dois crommossomos
sorteio[pos] <- pos
sorteados <- c(sorteados,which.min(erroQuadraticoMedio[sorteio]))
}
for (i in (order_size*prop_filhos+first_sorteados+2):cromo_quant){
sorteio <- rep(NA,cromo_quant)
pos <- sample(validos,2) # sorteio dois crommossomos
sorteio[pos] <- pos
sorteados <- c(sorteados,which.min(erroQuadraticoMedio[sorteio]))
}
C <- C[sorteados,]
## Cruzamento de Cromossomos
i <- (first_sorteados+1)
while (i < length(sorteados)){
# avalia a possibilidade de cruzamento de cada par
vai.cruzar <- runif(1)
if (vai.cruzar<=p.cruzamento){ # realiza cruzamento
pto.cruza <- endCromo[i]
if(pto.cruza > endCromo[i+1])
{
pto.cruza <- endCromo[i+1]
}
pto.cruza <- sample(pto.cruza-1,1)
index_pai <- i
index_mae <- i+1
tmp <- C[index_pai,(pto.cruza+1):cromo_size]
C[index_pai,(pto.cruza+1):cromo_size] <- C[index_mae,(pto.cruza+1):cromo_size]
C[index_mae,(pto.cruza+1):cromo_size] <- tmp
}
i <- i+2 # pula o próximo cromossomo (estamos olhando os pares)
}
## Mutação
vai.mutar <- matrix(runif(cromo_quant*cromo_size),cromo_quant,cromo_size)
divisa_prob <- cromo_quant%/%first_sorteados_fraction
for (i in (first_sorteados+1):cromo_quant){
linhaMutar <- vai.mutar[i,]
prob<-p.mutacao[i%/%divisa_prob+1]
if(prob*endCromo[i]<0.3)
{
prob <- 0.3/endCromo[i]
}
id <- which(linhaMutar < prob)
for (j in 1:length(id)){
coluna <- id[j]
C[i,coluna] <- sample(max_gene,1)
}
}
}
## Encontra as Últimas Derivações
## Gerando Derivação
S <- "<exp>"
derivacao <- rep(S,cromo_quant) # símbolo inicial
endCromo <- array(0,cromo_quant)
for (i in 1:cromo_quant) {
S <- "<exp>"
j <- 0
count <- 0
while (S!="<NA>"){
count <- count + 1
# evitar loop infinito, para cromossomos mal escolhidos:
if (count > cromo_size){
tmp <- stringr::str_match(derivacao[i], ".*?<")
tmp <- substr(tmp,1,nchar(tmp)-1)
if (is.na(tmp)){
last.char <- substr(tmp,nchar(derivacao[i]),nchar(derivacao[i]))
if (!last.char%in%var){
tmp <- substr(derivacao[i],1,nchar(derivacao[i])-1)
}
} else {
last.char <- substr(tmp,nchar(tmp),nchar(tmp))
while (!last.char%in%var){
# se terminar em operador
if (last.char%in%op){
tmp <- substr(tmp,1,nchar(tmp)-1)
} else if (substr(tmp,nchar(tmp)-1,nchar(tmp))=="^("){
tmp <- substr(tmp,1,nchar(tmp)-2)
} else if (substr(tmp,nchar(tmp)-5,nchar(tmp))=="asinh("){
tmp <- substr(tmp,1,nchar(tmp)-6)
}  else if (substr(tmp,nchar(tmp)-5,nchar(tmp))=="acosh("){
tmp <- substr(tmp,1,nchar(tmp)-6)
}  else if (substr(tmp,nchar(tmp)-5,nchar(tmp))=="atanh("){
tmp <- substr(tmp,1,nchar(tmp)-6)
} else if (substr(tmp,nchar(tmp)-1,nchar(tmp))=="h("){
tmp <- substr(tmp,1,nchar(tmp)-5)
} else if (substr(tmp,nchar(tmp)-4,nchar(tmp))=="sqrt("){
tmp <- substr(tmp,1,nchar(tmp)-5)
} else if (substr(tmp,nchar(tmp)-4,nchar(tmp))=="asin("){
tmp <- substr(tmp,1,nchar(tmp)-5)
}  else if (substr(tmp,nchar(tmp)-4,nchar(tmp))=="acos("){
tmp <- substr(tmp,1,nchar(tmp)-5)
}  else if (substr(tmp,nchar(tmp)-4,nchar(tmp))=="atan("){
tmp <- substr(tmp,1,nchar(tmp)-5)
} else if (last.char=="("){
tmp <- substr(tmp,1,nchar(tmp)-4)
}
last.char <- substr(tmp,nchar(tmp),nchar(tmp))
}
}
# colocar parênteses restantes
abrindo <- stringr::str_count(tmp,"\\(")
fechando <- stringr::str_count(tmp,"\\)")
add <- strrep(")",abrindo-fechando)
tmp <- paste(tmp,add,sep = "")
derivacao[i] <- tmp
S <- "<NA>"
}
j <- j%%cromo_size + 1
if (S=="<exp>"){
rule <- P[[1]][1+C[i,j]%%length(P[[1]])] # determina a regra a ser aplicada
derivacao[i] <- sub(S, rule, derivacao[i]) # atualiza derivacao por substituição
S <- stringr::str_match(derivacao[i], "<(.*?)>") # acha o primeiro <..>
S <- paste("<",S[,2],">",sep = "") # novo símbolo
} else if (S=="<op>"){
rule <- P[[2]][1+C[i,j]%%length(P[[2]])] # determina a regra a ser aplicada
derivacao[i] <- sub(S, rule, derivacao[i]) # atualiza derivacao por substituição
S <- stringr::str_match(derivacao[i], "<(.*?)>") # acha o primeiro <..>
S <- paste("<",S[,2],">",sep = "") # novo símbolo
} else if (S=="<var>"){
rule <- P[[3]][1+C[i,j]%%length(P[[3]])] # determina a regra a ser aplicada
derivacao[i] <- sub(S, rule, derivacao[i]) # atualiza derivacao por substituição
S <- stringr::str_match(derivacao[i], "<(.*?)>") # acha o primeiro <..>
S <- paste("<",S[,2],">",sep = "") # novo símbolo
}
}
endCromo[i] <- endCromo[i] + count
}
N <- 50 # número de gerações
ngeracoes <- ngeracoes + N
for (g in 1:N){
## Gerando Derivação
if(g%%5 == 0){
cat("Geração: ", g,"\n")
}
S <- "<exp>"
derivacao <- rep(S,cromo_quant) # símbolo inicial
endCromo <- array(0,cromo_quant)
for (i in 1:cromo_quant) {
S <- "<exp>"
j <- 0
count <- 0
while (S!="<NA>"){
count <- count + 1
# evitar loop infinito, para cromossomos mal escolhidos:
if (count > cromo_size){
tmp <- stringr::str_match(derivacao[i], ".*?<")
tmp <- substr(tmp,1,nchar(tmp)-1)
if (is.na(tmp)){
last.char <- substr(tmp,nchar(derivacao[i]),nchar(derivacao[i]))
if (!last.char%in%var){
tmp <- substr(derivacao[i],1,nchar(derivacao[i])-1)
}
} else {
last.char <- substr(tmp,nchar(tmp),nchar(tmp))
while (!last.char%in%var){
# se terminar em operador
if (last.char%in%op){
tmp <- substr(tmp,1,nchar(tmp)-1)
} else if (substr(tmp,nchar(tmp)-1,nchar(tmp))=="^("){
tmp <- substr(tmp,1,nchar(tmp)-2)
} else if (substr(tmp,nchar(tmp)-5,nchar(tmp))=="asinh("){
tmp <- substr(tmp,1,nchar(tmp)-6)
}  else if (substr(tmp,nchar(tmp)-5,nchar(tmp))=="acosh("){
tmp <- substr(tmp,1,nchar(tmp)-6)
}  else if (substr(tmp,nchar(tmp)-5,nchar(tmp))=="atanh("){
tmp <- substr(tmp,1,nchar(tmp)-6)
} else if (substr(tmp,nchar(tmp)-1,nchar(tmp))=="h("){
tmp <- substr(tmp,1,nchar(tmp)-5)
} else if (substr(tmp,nchar(tmp)-4,nchar(tmp))=="sqrt("){
tmp <- substr(tmp,1,nchar(tmp)-5)
} else if (substr(tmp,nchar(tmp)-4,nchar(tmp))=="asin("){
tmp <- substr(tmp,1,nchar(tmp)-5)
}  else if (substr(tmp,nchar(tmp)-4,nchar(tmp))=="acos("){
tmp <- substr(tmp,1,nchar(tmp)-5)
}  else if (substr(tmp,nchar(tmp)-4,nchar(tmp))=="atan("){
tmp <- substr(tmp,1,nchar(tmp)-5)
} else if (last.char=="("){
tmp <- substr(tmp,1,nchar(tmp)-4)
}
last.char <- substr(tmp,nchar(tmp),nchar(tmp))
}
endCromo[i] <- -1
}
# colocar parênteses restantes
abrindo <- stringr::str_count(tmp,"\\(")
fechando <- stringr::str_count(tmp,"\\)")
add <- strrep(")",abrindo-fechando)
tmp <- paste(tmp,add,sep = "")
derivacao[i] <- tmp
S <- "<NA>"
}
j <- j%%cromo_size + 1
if (S=="<exp>"){
rule <- P[[1]][1+C[i,j]%%length(P[[1]])] # determina a regra a ser aplicada
derivacao[i] <- sub(S, rule, derivacao[i]) # atualiza derivacao por substituição
S <- stringr::str_match(derivacao[i], "<(.*?)>") # acha o primeiro <..>
S <- paste("<",S[,2],">",sep = "") # novo símbolo
} else if (S=="<op>"){
rule <- P[[2]][1+C[i,j]%%length(P[[2]])] # determina a regra a ser aplicada
derivacao[i] <- sub(S, rule, derivacao[i]) # atualiza derivacao por substituição
S <- stringr::str_match(derivacao[i], "<(.*?)>") # acha o primeiro <..>
S <- paste("<",S[,2],">",sep = "") # novo símbolo
} else if (S=="<var>"){
rule <- P[[3]][1+C[i,j]%%length(P[[3]])] # determina a regra a ser aplicada
derivacao[i] <- sub(S, rule, derivacao[i]) # atualiza derivacao por substituição
S <- stringr::str_match(derivacao[i], "<(.*?)>") # acha o primeiro <..>
S <- paste("<",S[,2],">",sep = "") # novo símbolo
}
}
endCromo[i] <- endCromo[i] + count
}
## Avaliação dos Cromossomos
training.model <- trainingData[,c("strength")]
erroQuadraticoMedio <- rep(0,cromo_quant)
for (k in 1:cromo_quant){
training.data <- c()
for (i in 1:length(training.model)){
x <- trainingData[i,2]
y <- trainingData[i,3]
z <- trainingData[i,4]
u <- trainingData[i,5]
v <- trainingData[i,6]
w <- trainingData[i,7]
p <- trainingData[i,8]
q <- trainingData[i,9]
valor <- suppressWarnings(eval(parse(text=derivacao[k])))
training.data <- c(training.data,valor)
}
erroQuadraticoMedio[k] <- mean((training.data - (training.model))^2)
}
## Torneio de Cromossomos
sorteados <- c()
invalidosNanInf <- which(erroQuadraticoMedio %in% c(NaN,Inf))
invalidosVazio <- which(derivacao %in% c(""))
invalidos <- c(invalidosNanInf,invalidosVazio,which(duplicated(derivacao)))
validos <-c(1:length(derivacao))[which(!c(1:length(derivacao)) %in% invalidos)]
first_sorteados <- length(validos)%/%first_sorteados_fraction
order_size <- (order_size_fraction*length(validos))%/%first_sorteados_fraction
ordenados <- validos[order(erroQuadraticoMedio[validos])][1:order_size]
sorteados <- validos[order(erroQuadraticoMedio[validos])][1:first_sorteados]
if(length(sorteados)>0)
{
if(sqrt(erroQuadraticoMedio[sorteados[1]])<raizErroQuadraticoMedioMin)
{
raizErroQuadraticoMedioMin<-sqrt(erroQuadraticoMedio[sorteados[1]])
cromossomo_vencedor <- C[sorteados[1],]
derivacao_vencedora <- derivacao[sorteados[1]]
cat("Achou pto de mínimo: ",raizErroQuadraticoMedioMin," com derivação: ",derivacao_vencedora,"\n")
}
}
for (i in (first_sorteados+1):(order_size*prop_filhos+first_sorteados+1)){
sorteio <- rep(NA,cromo_quant)
pos <- sample(ordenados,2) # sorteio dois crommossomos
sorteio[pos] <- pos
sorteados <- c(sorteados,which.min(erroQuadraticoMedio[sorteio]))
}
for (i in (order_size*prop_filhos+first_sorteados+2):cromo_quant){
sorteio <- rep(NA,cromo_quant)
pos <- sample(validos,2) # sorteio dois crommossomos
sorteio[pos] <- pos
sorteados <- c(sorteados,which.min(erroQuadraticoMedio[sorteio]))
}
C <- C[sorteados,]
## Cruzamento de Cromossomos
i <- (first_sorteados+1)
while (i < length(sorteados)){
# avalia a possibilidade de cruzamento de cada par
vai.cruzar <- runif(1)
if (vai.cruzar<=p.cruzamento){ # realiza cruzamento
pto.cruza <- endCromo[i]
if(pto.cruza > endCromo[i+1])
{
pto.cruza <- endCromo[i+1]
}
pto.cruza <- sample(pto.cruza-1,1)
index_pai <- i
index_mae <- i+1
tmp <- C[index_pai,(pto.cruza+1):cromo_size]
C[index_pai,(pto.cruza+1):cromo_size] <- C[index_mae,(pto.cruza+1):cromo_size]
C[index_mae,(pto.cruza+1):cromo_size] <- tmp
}
i <- i+2 # pula o próximo cromossomo (estamos olhando os pares)
}
## Mutação
vai.mutar <- matrix(runif(cromo_quant*cromo_size),cromo_quant,cromo_size)
divisa_prob <- cromo_quant%/%first_sorteados_fraction
for (i in (first_sorteados+1):cromo_quant){
linhaMutar <- vai.mutar[i,]
prob<-p.mutacao[i%/%divisa_prob+1]
if(prob*endCromo[i]<0.3)
{
prob <- 0.3/endCromo[i]
}
id <- which(linhaMutar < prob)
for (j in 1:length(id)){
coluna <- id[j]
C[i,coluna] <- sample(max_gene,1)
}
}
}
