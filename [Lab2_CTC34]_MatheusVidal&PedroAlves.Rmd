---
title: "Concrete Compressive Strength"
subtitle: "CTC-34_Lab2: Evolução Grmátical"
author: "Matheus Vidal & Pedro Alves"
date: "17/11/2019"
output:
  html_document: default
  pdf_document: default
  word_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Definição da Gramática

```{r}
# Limpa área de trabalho
rm(list = ls())

# Não Terminais
V <- c("<exp>","<op>","<var>")

# Terminais
op <- c("+","-","/","*","^")
var <- c("x","y","z","u","v","w","p","q")
sigma <- c(op,var)

#sigma <- c("+","-","/","*","x","y")

# Símbolo Inicial
S <- "<exp>"

# Produções
P <- list(c("<exp><op><exp>","<var>"),op,var)

```

## Definindo os Cromossomos
```{r}
cromo_size <- 100
cromo_quant <- 200
max_gene <- 10000
C <- matrix(sample(max_gene,cromo_size),cromo_quant,cromo_size) # Ci = C[i,]

```

## Carregamento dos Dados de Treinamento

```{r}
trainingData <- read.csv(file="training.csv", header=TRUE, sep=",")

```

## Gerando Derivação

```{r}
# SOMENTE PARA TESTE
#C[1,] <- c(4,15,75,8,41,12)
#C[2,] <- c(6,10,255,7,50,35)
#C[3,] <- c(9,40,7,43,2,11)
#C[4,] <- c(20,5,200,5,67,23)
# FIM
derivacao <- rep(S,cromo_quant) # símbolo inicial
for (i in 1:cromo_quant) {
  S <- "<exp>"
  j <- 0
  count <- 0
  while (S!="<NA>"){
    count <- count + 1
    # evitar loop infinito, para cromossomos mal escolhidos:
    if (count > 100){
      tmp <- stringr::str_match(derivacao[i], ".*?<")
      tmp <- substr(tmp,1,nchar(tmp)-1)
      last.char <- substr(tmp,nchar(tmp),nchar(tmp))
      if (!last.char%in%var || is.na(tmp)){ # se terminar em operador
        tmp <- substr(tmp,1,nchar(tmp)-1)  
      }
      derivacao[i] <- tmp
      S <- "<NA>"
    }
    j <- j%%cromo_size + 1
    if (S=="<exp>"){
      rule <- P[[1]][1+C[i,j]%%length(P[[1]])] # determina a regra a ser aplicada
      derivacao[i] <- sub(S, rule, derivacao[i]) # atualiza derivacao por substituição
      S <- stringr::str_match(derivacao[i], "<(.*?)>") # acha o primeiro <..>
      S <- paste("<",S[,2],">",sep = "") # novo símbolo
    } else if (S=="<op>"){
      rule <- P[[2]][1+C[i,j]%%length(P[[2]])] # determina a regra a ser aplicada
      derivacao[i] <- sub(S, rule, derivacao[i]) # atualiza derivacao por substituição
      S <- stringr::str_match(derivacao[i], "<(.*?)>") # acha o primeiro <..>
      S <- paste("<",S[,2],">",sep = "") # novo símbolo
    } else if (S=="<var>"){
      rule <- P[[3]][1+C[i,j]%%length(P[[3]])] # determina a regra a ser aplicada
      derivacao[i] <- sub(S, rule, derivacao[i]) # atualiza derivacao por substituição
      S <- stringr::str_match(derivacao[i], "<(.*?)>") # acha o primeiro <..>
      S <- paste("<",S[,2],">",sep = "") # novo símbolo
    }
  }
}
```

## Caso de Teste

```{r}
#testData <- rbind(c(0.9,0.8,1.61),c(0.3,0.1,0.19),c(0.5,0.2,0.45),c(0.88,0.5,1.2744),c(0.6,0.7,1.06))

```

## Avaliação dos Cromossomos

```{r}
training.model <- trainingData[,c("strength")]
#training.model <- testData[,3]
erroQuadraticoMedio <- rep(0,cromo_quant)
for (k in 1:cromo_quant){
  training.data <- c()
  for (i in 1:length(training.model)){
    #x <- testData[i,1]
    #y <- testData[i,2]
    x <- trainingData[i,2]
    y <- trainingData[i,3]
    z <- trainingData[i,4]
    u <- trainingData[i,5]
    v <- trainingData[i,6]
    w <- trainingData[i,7]
    p <- trainingData[i,8]
    q <- trainingData[i,9]
    training.data <- c(training.data,eval(parse(text=derivacao[k])))
  }
  erroQuadraticoMedio[k] <- mean((training.data - (training.model))^2) 
}
erroQuadraticoMedio
```

## Torneio de Cromossomos

```{r}
sorteados <- c()
#pos <- rbind(c(1,3),c(2,3),c(3,4),c(2,4))
for (i in 1:cromo_quant){
  sorteio <- rep(NA,cromo_quant)
  pos <- sample(cromo_quant,2) # sorteio dois crommossomos
  #sorteio[pos[i,]] <- pos[i,]
  sorteio[pos] <- pos
  sorteados <- c(sorteados,which.min(erroQuadraticoMedio[sorteio]))
}

sorteados
```

## Cruzamento de Cromossomos

```{r}
p.cruzamento <- 0.8
i <- 1
while (i < length(sorteados)){
  # avalia a possibilidade de cruzamento de cada par
  vai.cruzar <- runif(1)
  if (vai.cruzar<=p.cruzamento){ # realiza cruzamento
    pto.cruza <- sample(cromo_size-1,1)
    index_pai <- sorteados[i]
    index_mae <- sorteados[i+1]
    tmp <- C[index_pai,(pto.cruza+1):cromo_size]
    C[index_pai,(pto.cruza+1):cromo_size] <- C[index_mae,(pto.cruza+1):cromo_size] 
    C[index_mae,(pto.cruza+1):cromo_size] <- tmp
  }
  i <- i+2 # pula o próximo cromossomo (estamos olhando os pares)
}
```

## Mutação

```{r}
p.mutacao <- 0.1
vai.mutar <- runif(cromo_size*cromo_quant)
for (i in 1:length(vai.mutar)){
  if (vai.mutar[i]<p.mutacao){
    linha <- i%%cromo_quant+1
    coluna <- (i-cromo_size*(i%%cromo_quant))%%cromo_size
    C[linha,coluna] <- sample(max_gene,1)
  }
}
```

## Após N Gerações

Repetindo para N gerações.

```{r}
N <- 200 # número de gerações
for (g in 1:N){
  ## Gerando Derivação

  S <- "<exp>"
  derivacao <- rep(S,cromo_quant) # símbolo inicial
  for (i in 1:cromo_quant) {
    S <- "<exp>"
    j <- 0
    count <- 0
    while (S!="<NA>"){
      count <- count + 1
      # evitar loop infinito, para cromossomos mal escolhidos:
      if (count > 100){
        tmp <- stringr::str_match(derivacao[i], ".*?<")
        tmp <- substr(tmp,1,nchar(tmp)-1)
        last.char <- substr(tmp,nchar(tmp),nchar(tmp))
        if (!last.char%in%var || is.na(tmp)){ # se terminar em operador
          tmp <- substr(tmp,1,nchar(tmp)-1)  
        }
        derivacao[i] <- tmp
        S <- "<NA>"
      }
      j <- j%%cromo_size + 1
      if (S=="<exp>"){
        rule <- P[[1]][1+C[i,j]%%length(P[[1]])] # determina a regra a ser aplicada
        derivacao[i] <- sub(S, rule, derivacao[i]) # atualiza derivacao por substituição
        S <- stringr::str_match(derivacao[i], "<(.*?)>") # acha o primeiro <..>
        S <- paste("<",S[,2],">",sep = "") # novo símbolo
      } else if (S=="<op>"){
        rule <- P[[2]][1+C[i,j]%%length(P[[2]])] # determina a regra a ser aplicada
        derivacao[i] <- sub(S, rule, derivacao[i]) # atualiza derivacao por substituição
        S <- stringr::str_match(derivacao[i], "<(.*?)>") # acha o primeiro <..>
        S <- paste("<",S[,2],">",sep = "") # novo símbolo
      } else if (S=="<var>"){
        rule <- P[[3]][1+C[i,j]%%length(P[[3]])] # determina a regra a ser aplicada
        derivacao[i] <- sub(S, rule, derivacao[i]) # atualiza derivacao por substituição
        S <- stringr::str_match(derivacao[i], "<(.*?)>") # acha o primeiro <..>
        S <- paste("<",S[,2],">",sep = "") # novo símbolo
      }
    }
  }
  
  ## Avaliação dos Cromossomos
  
  training.model <- trainingData[,c("strength")]
  erroQuadraticoMedio <- rep(0,cromo_quant)
  for (k in 1:cromo_quant){
    training.data <- c()
    for (i in 1:length(training.model)){
      x <- trainingData[i,2]
      y <- trainingData[i,3]
      z <- trainingData[i,4]
      u <- trainingData[i,5]
      v <- trainingData[i,6]
      w <- trainingData[i,7]
      p <- trainingData[i,8]
      q <- trainingData[i,9]
      training.data <- c(training.data,eval(parse(text=derivacao[k])))
    }
    erroQuadraticoMedio[k] <- mean((training.data - (training.model))^2) 
  }
  erroQuadraticoMedio
  
  ## Torneio de Cromossomos
  
  sorteados <- c()
  for (i in 1:cromo_quant){
    sorteio <- rep(NA,cromo_quant)
    pos <- sample(cromo_quant,2) # sorteio dois crommossomos
    sorteio[pos] <- pos
    sorteados <- c(sorteados,which.min(erroQuadraticoMedio[sorteio]))
  }
  
  sorteados
  
  ## Cruzamento de Cromossomos
  
  p.cruzamento <- 0.8
  i <- 1
  while (i < length(sorteados)){
    # avalia a possibilidade de cruzamento de cada par
    vai.cruzar <- runif(1)
    if (vai.cruzar<=p.cruzamento){ # realiza cruzamento
      pto.cruza <- sample(cromo_size-1,1)
      index_pai <- sorteados[i]
      index_mae <- sorteados[i+1]
      tmp <- C[index_pai,(pto.cruza+1):cromo_size]
      C[index_pai,(pto.cruza+1):cromo_size] <- C[index_mae,(pto.cruza+1):cromo_size] 
      C[index_mae,(pto.cruza+1):cromo_size] <- tmp
    }
    i <- i+2 # pula o próximo cromossomo (estamos olhando os pares)
  }
  
  ## Mutação
  
  p.mutacao <- 0.1
  vai.mutar <- runif(cromo_size*cromo_quant)
  for (i in 1:length(vai.mutar)){
    if (vai.mutar[i]<p.mutacao){
      linha <- i%%cromo_quant+1
      coluna <- (i-cromo_size*(i%%cromo_quant))%%cromo_size
      C[linha,coluna] <- sample(max_gene,1)
    }
  }

}
```

## Escolha do Cromossomo Vencedor

Escolhemos o melhor cromossomo, <i>i.e.</i>, o de menor erro quadrático médio.

```{r}
training.model <- trainingData[,c("strength")]
erroQuadraticoMedio <- rep(0,cromo_quant)
for (k in 1:cromo_quant){
  training.data <- c()
  for (i in 1:length(training.model)){
    x <- trainingData[i,2]
    y <- trainingData[i,3]
    z <- trainingData[i,4]
    u <- trainingData[i,5]
    v <- trainingData[i,6]
    w <- trainingData[i,7]
    p <- trainingData[i,8]
    q <- trainingData[i,9]
    training.data <- c(training.data,eval(parse(text=derivacao[k])))
  }
  erroQuadraticoMedio[k] <- mean((training.data - (training.model))^2) 
}

# Cromossomo vencedor:
vencedor <- which.min(erroQuadraticoMedio)
vencedor
```

## Carregamento dos Dados de Teste

```{r}
testingData <- read.csv(file="testing.csv", header=TRUE, sep=",")

```

## Predição de Dados

Vamos aplicar o cromossomo vencedor para predizer o dado de saída a partir de entradas advindas de <i>testing.csv</i>.


```{r}
predict.data <- c()
for (i in 1:dim(testingData)[1]){
  x <- trainingData[i,2]
  y <- trainingData[i,3]
  z <- trainingData[i,4]
  u <- trainingData[i,5]
  v <- trainingData[i,6]
  w <- trainingData[i,7]
  p <- trainingData[i,8]
  q <- trainingData[i,9]
  predict.data <- c(predict.data,eval(parse(text=derivacao[vencedor])))
}
```

```{r}
#plot
plot(predict.data)

```

```{r}
# boxplot
boxplot(predict.data)

```

## Construindo predicted.csv
```{r}
ID <- testingData[c("ID")]
result <- data.frame(ID,predict.data)
colnames(result) <- c("ID", "strength")
write.table(result,file="predicted.csv",col.names = c("ID","strength"),sep = ",")
result.data <- read.csv(file="predicted.csv", header=TRUE, sep=",")

```


## Comparando com o testing.csv

```{r}
testing.data <- testingData[,c("strength")]

raizErroQuadraticoMedio <- sqrt(mean((predict.data - (testing.data))^2))
raizErroQuadraticoMedio

```

```{r}
 plot(predict.data,testing.data,
      xlab="predicted",ylab="actual")
 abline(a=0,b=1)

```

