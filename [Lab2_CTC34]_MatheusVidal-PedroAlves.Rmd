---
title: "Concrete Compressive Strength"
subtitle: "CTC-34_Lab2: Evolução Grmátical"
author: "Matheus Vidal & Pedro Alves"
date: "17/11/2019"
output:
  html_document: default
  pdf_document: default
  word_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Definição da Gramática

```{r}
# Limpa área de trabalho
rm(list = ls())

# Não Terminais
V <- c("<exp>","<op>","<var>","<sin>","<cos>","<log>","<e>","<^>","<abs>","<inc>","<dec>","<const>")

# Terminais
op <- c("+","-","/","*")

var <- c("x","y","z","u","v","w","p","q")
sigma <- c(op,var)

#sigma <- c("+","-","/","*","x","y")

# Símbolo Inicial
S <- "<exp>"

# Produções
basicas <- rep(c("<exp><op><exp>"),30)
variavel <- rep(c("<var>"),10)
seno <- c("sin(<var>)","sin(<var><op><exp>)")
cosseno <- c("cos(<var>)","cos(<var><op><exp>)")
logaritmo <- c("log(<var>)","log(<var><op><exp>)")
exp_natural <- c("exp(<var>)","exp(<var><op><exp>)")
exponencial <- c("<exp>^(<var>)","<exp>^(<var><op><exp>)")
modulo <- c("abs(<var>)","abs(<var><op><exp>)")
incremento <- c("<var>+1","<var>+1<op><exp>")
decremento <- c("<var>-1","<var>-1<op><exp>")

# Geração de constantes
max_const <- 1
const_quant <- 1000
amostra <- 1
const <- runif(const_quant,min = -max_const,max=max_const)
constante <- const[sample(max_const,amostra)]


P <- list(c(basicas,seno,cosseno,logaritmo,exp_natural,exponencial,modulo,incremento,decremento,constante),op,var)
#P <- list(c("<exp><op><exp>","<var>"),op,var)

```

## Definindo os Cromossomos
```{r}
cromo_size <- 100
cromo_quant <- 1000
max_gene <- 100000
C <- matrix(sample(max_gene,cromo_size*cromo_quant),cromo_quant,cromo_size) # Ci = C[i,]

```

## Carregamento dos Dados de Treinamento

```{r}
trainingData <- read.csv(file="training.csv", header=TRUE, sep=",")

```

## Gerando Derivação

```{r}
# SOMENTE PARA TESTE
#C[1,] <- c(4,15,75,8,41,12)
#C[2,] <- c(6,10,255,7,50,35)
#C[3,] <- c(9,40,7,43,2,11)
#C[4,] <- c(20,5,200,5,67,23)
# FIM
S <- "<exp>"
derivacao <- rep(S,cromo_quant) # símbolo inicial
for (i in 1:cromo_quant) {
  S <- "<exp>"
  j <- 0
  count <- 0
  while (S!="<NA>"){
    count <- count + 1
    # evitar loop infinito, para cromossomos mal escolhidos:
    if (count > 30){
      tmp <- stringr::str_match(derivacao[i], ".*?<")
      tmp <- substr(tmp,1,nchar(tmp)-1)
      if (is.na(tmp)){
        last.char <- substr(tmp,nchar(derivacao[i]),nchar(derivacao[i]))
        if (!last.char%in%var){
          tmp <- substr(derivacao[i],1,nchar(derivacao[i])-1)  
        }
      }
      else {
        last.char <- substr(tmp,nchar(tmp),nchar(tmp))
        if (!last.char%in%var){ 
          # se terminar em operador
          if (last.char%in%op){
            tmp <- substr(tmp,1,nchar(tmp)-1)    
          } else if (substr(tmp,nchar(tmp)-1,nchar(tmp))=="^("){
            tmp <- substr(tmp,1,nchar(tmp)-2)
          } else if (last.char=="("){
            tmp <- substr(tmp,1,nchar(tmp)-4)    
          }
        }
        last.char <- substr(tmp,nchar(tmp),nchar(tmp))
        # se terminar em operador
        if (last.char%in%op){
          tmp <- substr(tmp,1,nchar(tmp)-1)    
        }
      }
      # colocar parênteses restantes
      abrindo <- stringr::str_count(tmp,"\\(")
      fechando <- stringr::str_count(tmp,"\\)")
      add <- strrep(")",abrindo-fechando)
      tmp <- paste(tmp,add,sep = "")
    
      derivacao[i] <- tmp
      S <- "<NA>"
    }
    j <- j%%cromo_size + 1
    if (S=="<exp>"){
      rule <- P[[1]][1+C[i,j]%%length(P[[1]])] # determina a regra a ser aplicada
      derivacao[i] <- sub(S, rule, derivacao[i]) # atualiza derivacao por substituição
      S <- stringr::str_match(derivacao[i], "<(.*?)>") # acha o primeiro <..>
      S <- paste("<",S[,2],">",sep = "") # novo símbolo
    } else if (S=="<op>"){
      rule <- P[[2]][1+C[i,j]%%length(P[[2]])] # determina a regra a ser aplicada
      derivacao[i] <- sub(S, rule, derivacao[i]) # atualiza derivacao por substituição
      S <- stringr::str_match(derivacao[i], "<(.*?)>") # acha o primeiro <..>
      S <- paste("<",S[,2],">",sep = "") # novo símbolo
    } else if (S=="<var>"){
      rule <- P[[3]][1+C[i,j]%%length(P[[3]])] # determina a regra a ser aplicada
      derivacao[i] <- sub(S, rule, derivacao[i]) # atualiza derivacao por substituição
      S <- stringr::str_match(derivacao[i], "<(.*?)>") # acha o primeiro <..>
      S <- paste("<",S[,2],">",sep = "") # novo símbolo
    }
  }
}
```

## Caso de Teste

```{r}
#testData <- rbind(c(0.9,0.8,1.61),c(0.3,0.1,0.19),c(0.5,0.2,0.45),c(0.88,0.5,1.2744),c(0.6,0.7,1.06))

```

## Avaliação dos Cromossomos

```{r}
options(warn = -1)
training.model <- trainingData[,c("strength")]
#training.model <- testData[,3]
erroQuadraticoMedio <- rep(Inf,cromo_quant)
for (k in 1:cromo_quant){
  training.data <- c()
  caso.nan <- FALSE
  for (i in 1:length(training.model)){
    #x <- testData[i,1]
    #y <- testData[i,2]
    x <- trainingData[i,2]
    y <- trainingData[i,3]
    z <- trainingData[i,4]
    u <- trainingData[i,5]
    v <- trainingData[i,6]
    w <- trainingData[i,7]
    p <- trainingData[i,8]
    q <- trainingData[i,9]
    valor <- suppressWarnings(eval(parse(text=derivacao[k]))) 
    training.data <- c(training.data,valor)
  }
  erroQuadraticoMedio[k] <- mean((training.data - (training.model))^2) 
}
options(warn = 0)
erroQuadraticoMedio
```

## Torneio de Cromossomos

```{r}
sorteados <- c()
#pos <- rbind(c(1,3),c(2,3),c(3,4),c(2,4))
validos <- which(!erroQuadraticoMedio %in% c(NaN,Inf))
for (i in 1:cromo_quant){
  sorteio <- rep(NA,cromo_quant)
  pos <- sample(validos,2) # sorteio dois crommossomos
  #sorteio[pos[i,]] <- pos[i,]
  sorteio[pos] <- pos
  sorteados <- c(sorteados,which.min(erroQuadraticoMedio[sorteio]))
}

sorteados
```

## Cruzamento de Cromossomos

```{r}
p.cruzamento <- 0.8
i <- 1
while (i < length(sorteados)){
  # avalia a possibilidade de cruzamento de cada par
  vai.cruzar <- runif(1)
  if (vai.cruzar<=p.cruzamento){ # realiza cruzamento
    pto.cruza <- sample(cromo_size-1,1)
    index_pai <- sorteados[i]
    index_mae <- sorteados[i+1]
    tmp <- C[index_pai,(pto.cruza+1):cromo_size]
    C[index_pai,(pto.cruza+1):cromo_size] <- C[index_mae,(pto.cruza+1):cromo_size] 
    C[index_mae,(pto.cruza+1):cromo_size] <- tmp
  }
  i <- i+2 # pula o próximo cromossomo (estamos olhando os pares)
}
```

## Mutação

```{r}
p.mutacao <- 0.1
vai.mutar <- runif(cromo_size*cromo_quant)
for (i in 1:length(vai.mutar)){
  if (vai.mutar[i]<p.mutacao){
    linha <- i%%cromo_quant+1
    coluna <- (i-cromo_size*(i%%cromo_quant))%%cromo_size
    C[linha,coluna] <- sample(max_gene,1)
  }
}
```

## Após N Gerações

Repetindo para N gerações.

```{r}
N <- 25 # número de gerações
for (g in 1:N){
  ## Gerando Derivação

  S <- "<exp>"
  derivacao <- rep(S,cromo_quant) # símbolo inicial
  for (i in 1:cromo_quant) {
    S <- "<exp>"
    j <- 0
    count <- 0
    while (S!="<NA>"){
      count <- count + 1
      # evitar loop infinito, para cromossomos mal escolhidos:
      if (count > 30){
        tmp <- stringr::str_match(derivacao[i], ".*?<")
        tmp <- substr(tmp,1,nchar(tmp)-1)
        if (is.na(tmp)){
          last.char <- substr(tmp,nchar(derivacao[i]),nchar(derivacao[i]))
          if (!last.char%in%var){
            tmp <- substr(derivacao[i],1,nchar(derivacao[i])-1)  
          }
        }
        else {
          last.char <- substr(tmp,nchar(tmp),nchar(tmp))
          if (!last.char%in%var){ 
            # se terminar em operador
            if (last.char%in%op){
              tmp <- substr(tmp,1,nchar(tmp)-1)    
            } else if (substr(tmp,nchar(tmp)-1,nchar(tmp))=="^("){
              tmp <- substr(tmp,1,nchar(tmp)-2)
            } else if (last.char=="("){
              tmp <- substr(tmp,1,nchar(tmp)-4)    
            }
          }
          last.char <- substr(tmp,nchar(tmp),nchar(tmp))
          # se terminar em operador
          if (last.char%in%op){
            tmp <- substr(tmp,1,nchar(tmp)-1)    
          }
        }
        # colocar parênteses restantes
        abrindo <- stringr::str_count(tmp,"\\(")
        fechando <- stringr::str_count(tmp,"\\)")
        add <- strrep(")",abrindo-fechando)
        tmp <- paste(tmp,add,sep = "")
      
        derivacao[i] <- tmp
        S <- "<NA>"
      }
      j <- j%%cromo_size + 1
      if (S=="<exp>"){
        rule <- P[[1]][1+C[i,j]%%length(P[[1]])] # determina a regra a ser aplicada
        derivacao[i] <- sub(S, rule, derivacao[i]) # atualiza derivacao por substituição
        S <- stringr::str_match(derivacao[i], "<(.*?)>") # acha o primeiro <..>
        S <- paste("<",S[,2],">",sep = "") # novo símbolo
      } else if (S=="<op>"){
        rule <- P[[2]][1+C[i,j]%%length(P[[2]])] # determina a regra a ser aplicada
        derivacao[i] <- sub(S, rule, derivacao[i]) # atualiza derivacao por substituição
        S <- stringr::str_match(derivacao[i], "<(.*?)>") # acha o primeiro <..>
        S <- paste("<",S[,2],">",sep = "") # novo símbolo
      } else if (S=="<var>"){
        rule <- P[[3]][1+C[i,j]%%length(P[[3]])] # determina a regra a ser aplicada
        derivacao[i] <- sub(S, rule, derivacao[i]) # atualiza derivacao por substituição
        S <- stringr::str_match(derivacao[i], "<(.*?)>") # acha o primeiro <..>
        S <- paste("<",S[,2],">",sep = "") # novo símbolo
      }
    }
  }
  
  ## Avaliação dos Cromossomos
  
  training.model <- trainingData[,c("strength")]
  erroQuadraticoMedio <- rep(0,cromo_quant)
  for (k in 1:cromo_quant){
    training.data <- c()
    for (i in 1:length(training.model)){
      x <- trainingData[i,2]
      y <- trainingData[i,3]
      z <- trainingData[i,4]
      u <- trainingData[i,5]
      v <- trainingData[i,6]
      w <- trainingData[i,7]
      p <- trainingData[i,8]
      q <- trainingData[i,9]
      valor <- suppressWarnings(eval(parse(text=derivacao[k]))) 
      training.data <- c(training.data,valor)
    }
    erroQuadraticoMedio[k] <- mean((training.data - (training.model))^2) 
  }
  erroQuadraticoMedio
  
  ## Torneio de Cromossomos
  
  sorteados <- c()
  #pos <- rbind(c(1,3),c(2,3),c(3,4),c(2,4))
  validos <- which(!erroQuadraticoMedio %in% c(NaN,Inf))
  for (i in 1:cromo_quant){
    sorteio <- rep(NA,cromo_quant)
    pos <- sample(validos,2) # sorteio dois crommossomos
    #sorteio[pos[i,]] <- pos[i,]
    sorteio[pos] <- pos
    sorteados <- c(sorteados,which.min(erroQuadraticoMedio[sorteio]))
  }
  
  sorteados
  
  ## Cruzamento de Cromossomos
  
  p.cruzamento <- 0.8
  i <- 1
  while (i < length(sorteados)){
    # avalia a possibilidade de cruzamento de cada par
    vai.cruzar <- runif(1)
    if (vai.cruzar<=p.cruzamento){ # realiza cruzamento
      pto.cruza <- sample(cromo_size-1,1)
      index_pai <- sorteados[i]
      index_mae <- sorteados[i+1]
      tmp <- C[index_pai,(pto.cruza+1):cromo_size]
      C[index_pai,(pto.cruza+1):cromo_size] <- C[index_mae,(pto.cruza+1):cromo_size] 
      C[index_mae,(pto.cruza+1):cromo_size] <- tmp
    }
    i <- i+2 # pula o próximo cromossomo (estamos olhando os pares)
  }
  
  ## Mutação
  
  p.mutacao <- 0.1
  vai.mutar <- runif(cromo_size*cromo_quant)
  for (i in 1:length(vai.mutar)){
    if (vai.mutar[i]<p.mutacao){
      linha <- i%%cromo_quant+1
      coluna <- (i-cromo_size*(i%%cromo_quant))%%cromo_size
      C[linha,coluna] <- sample(max_gene,1)
    }
  }

}
```

## Escolha do Cromossomo Vencedor

Escolhemos o melhor cromossomo, <i>i.e.</i>, o de menor erro quadrático médio.

```{r}
training.model <- trainingData[,c("strength")]
erroQuadraticoMedio <- rep(0,cromo_quant)
for (k in 1:cromo_quant){
  training.data <- c()
  for (i in 1:length(training.model)){
    x <- trainingData[i,2]
    y <- trainingData[i,3]
    z <- trainingData[i,4]
    u <- trainingData[i,5]
    v <- trainingData[i,6]
    w <- trainingData[i,7]
    p <- trainingData[i,8]
    q <- trainingData[i,9]
    valor <- suppressWarnings(eval(parse(text=derivacao[k]))) 
    training.data <- c(training.data,valor)
  }
  erroQuadraticoMedio[k] <- mean((training.data - (training.model))^2) 
}

# Cromossomo vencedor:
vencedor <- which.min(erroQuadraticoMedio)
vencedor
derivacao[vencedor]
```

## Carregamento dos Dados de Teste

```{r}
testingData <- read.csv(file="testing.csv", header=TRUE, sep=",")

```

## Predição de Dados

Vamos aplicar o cromossomo vencedor para predizer o dado de saída a partir de entradas advindas de <i>testing.csv</i>.


```{r}
predict.data <- c()
for (i in 1:dim(testingData)[1]){
  x <- trainingData[i,2]
  y <- trainingData[i,3]
  z <- trainingData[i,4]
  u <- trainingData[i,5]
  v <- trainingData[i,6]
  w <- trainingData[i,7]
  p <- trainingData[i,8]
  q <- trainingData[i,9]
  predict.data <- c(predict.data,eval(parse(text=derivacao[vencedor])))
}
```

```{r}
#plot
plot(predict.data)

```

```{r}
# boxplot
boxplot(predict.data)

```

## Construindo predicted.csv
```{r}
ID <- testingData[c("ID")]
result <- data.frame(ID,predict.data)
colnames(result) <- c("ID", "strength")
write.table(result,file="predicted.csv",col.names = c("ID","strength"),sep = ",")
result.data <- read.csv(file="predicted.csv", header=TRUE, sep=",")

```


## Comparando com o testing.csv

```{r}
testing.data <- testingData[,c("strength")]

raizErroQuadraticoMedio <- sqrt(mean((predict.data - (testing.data))^2))
raizErroQuadraticoMedio

```

```{r}
 plot(predict.data,testing.data,
      xlab="predicted",ylab="actual")
 abline(a=0,b=1)

```

